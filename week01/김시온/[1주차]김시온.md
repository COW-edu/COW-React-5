# 카우 웹 세션

📚 학습 주제
DOM과 Virtual DOM, MPA vs SPA, CSR vs SSR

# 웹 브라우저

## 웹

웹이란 인터넷 상에서 텍스트나 그림, 소리, 영상 등의 멀티미디어 정보를 하이퍼텍스트 방식으로 연결하여 제공하는 공간이다. 하이퍼텍스트는 참조(하이퍼링크)를 통해 한 문서에서 다른 문서로 즉시 이동할 수 있는 텍스트를 말한다. 하이퍼텍스트(또는 하이퍼링크)가 없었다면 자료를 인터넷이라는 공간이 아닌 로컬에 저장해야 했을 것이고, 자료를 공유할 때에도 링크 없이 다운로드 방식으로 모든 자료를 공유해야 했을 것이다. 양방향의 상호작용도 불가했을 것이다.

## 웹 브라우저의 동작 방식

웹 브라우저는 요청과 응답으로 작동한다. 사용자가 선택한 자원을 브라우저가 서버에 요청하고 서버로부터 받은 응답을 브라우저에 띄우는 방식이다. 이때 응답을 띄우는 것을 렌더링이라고 한다. 또한, 사용자가 선택한 자원은 HTML문서 외에도 PDF나 멀티미디어 등이 될 수 있으며 자원의 주소는 URI 형식이다.

<img width="524" alt="Image" src="https://github.com/user-attachments/assets/676266b6-2340-4d44-ba46-89eeca75f49b" />

웹 브라우저의 동작 과정은 다음과 같다. (위 사진의 과정을 글로 풀었다.)

1. 사용자가 웹 브라우저를 통해 찾고 싶은 웹 페이지의 URL 주소를 입력한다.
2. DNS 서버에서 사용자가 입력한 URL 주소 중 도메인 이름을 검색한다.
3. DNS 서버가 해당 도메인 이름에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.
4. HTTP 프로토콜을 사용하여 웹 페이지 URL 정보와 전달 받은 IP 주소를 바탕으로 HTTP 요청 메세지를 생성한다.
5. TCP 프로토콜을 사용하여 인터넷을 거친 뒤 해당 IP 컴퓨터로 전송한다.
6. HTTP 프로토콜을 통해 HTTP 요청 메세지가 웹 페이지 URL 정보로 변환된다.
7. 웹 서버가 변환된 URL 정보에 해당하는 데이터를 검색하여 찾는다.
8. HTTP 프로토콜을 통해 HTTP 응답 메세지를 생성한다.
9. TCP 프로토콜을 이용하여 HTTP 메세지가 인터넷을 거쳐 사용자의 컴퓨터로 전송된다.
10. 사용자의 컴퓨터에 도착한 HTTP 응답 메세지는 HTTP 프로토콜을 사용해 웹 페이지 데이터로 변환된다.
11. 변환된 데이터가 웹 브라우저에 출력되어 사용자가 볼 수 있게 된다.

## 브라우저의 구조

<img width="528" alt="Image" src="https://github.com/user-attachments/assets/dd46ff63-6591-4fcc-99e8-d8fc7a211ab5" />

브라우저의 구조는 위의 사진처럼 이루어져 있다.

- 사용자 인터페이스는 주소 표시줄, 이전/다음 버튼, 북마크 메뉴, 플러그인 버튼, 설정 버튼 등 브라우저와의 상호작용을 담당하는 요소를 의미한다.
- 브라우저 엔진은 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어하는 소프트웨어이다. Blink, Gecko, Webkit 등의 엔진이 사용되고 있으며 HTTP 요청을 통해 웹페이지를 가져와서 해석한 뒤 화면에 표시한다. 주요 기능은 아래와 같다.
  - HTML, CSS, JS 등을 처리하여 DOM 및 CSSOM을 생성한다.
  - 페이지 레이아웃 및 스타일을 계산하고 최종적인 화면 출력을 준비한다.
  - 사용자 입력과 상호작용을 관리한다.
- 렌더링 엔진은 웹페이지의 콘텐츠를 실제로 화면에 출력하는 역할을 한다. HTML, CSS 등을 파싱하여 레이아웃을 계산하고, 픽셀 단위의 화면을 그려주며 주로 HTML, XML 문서, CSS 스타일을 해석하지만 이미지나 SVG 같은 그래픽 요소도 표시할 수 있다.
  - 이런 저런 의견이 있어 정확하다고 하기에는 어렵지만, 렌더링 엔진 안의 레이아웃 엔진이HTML, CSS를 기반으로 페이지의 요소 위치와 스타일을 계산하는 역할을 한다.
  - 보통 렌더링 엔진과 레이아웃 엔진을 포함한 개념을 브라우저 엔진이라고 하는 듯하다. 하지만 엄밀히 말하자면 브라우저 엔진이 렌더링 엔진을 제어하는 역할을 한다.
- 통신은 HTTP 요청과 같이 웹 브라우저가 서버와 데이터를 주고받는 기능을 담당한다. 운영체제와는 독립적으로 설계된 인터페이스이고 각 플랫폼의 하부에서 실행된다. OS의 네트워크 스택들을 활용할 때 브라우저 자체에서 통신을 추상화하는 계층을 두어 여러 플랫폼에서 동작할 수 있도록 한다.
- 자바스크립트 해석기는 자바스크립트 엔진이라고도 하며 브라우저 내에서 웹 페이지에 포함된 자바스크립트 코드를 해석하고 실행하는 역할을 한다. 최근의 자바스크립트 엔진들은 코드를 실행하는 동안 코드의 일부를 기계어로 변환하는 Just-In-Time (JIT) 컴파일을 통해 코드 실행을 최적화한다. 대표적으로 크롬의 V8 엔진이 있다.
  - V8 엔진은 힙 메모리와 콜 스택으로 구성된다. 힙 메모리는 동적 메모리 할당에 사용되며 객체나 동적 데이터를 저장한다. 또한, 가비지 컬렉션이 발생한다.
  - 콜 스택은 JS 코드가 실행되며 생성되는 실행 컨텍스트를 저장한다. JS는 싱글 스레드 기반이기 때문에 콜 스택에서 한 번에 한 작업만 실행하게 된다.
- UI 백엔드는 렌더링 엔진이 분석한 렌더 트리를 브라우저에 그리는 역할을 한다. 주로 select와 input 같은 기본적인 위젯을 렌더링한다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로 OS 사용자 인터페이스 체계를 사용한다.
- 자료 저장소는 말 그대로 자료를 저장하는 역할을 하며 로컬 스토리지(영구적인 저장소)와 세션 스토리지(임시적인 저장소)로 구분된다.

## 브라우저 렌더링

<img width="586" alt="Image" src="https://github.com/user-attachments/assets/b70da2b9-36e8-4ed9-80c2-6b8ab5203c49" />

1. 브라우저를 통해 사용자가 웹 사이트에 접속한다.
2. 브라우저는 서버로부터 HTML, CSS, JS 같은 웹사이트에 필요한 리소스 다운한다.
3. 렌더링 엔진은 전달 받은 HTML 문서를 파싱하여 DOM 트리 생성한다.
4. 다운 받은 외부 CSS 파일과 함께 포함된 스타일 요소를 파싱하여 CSSOM 트리를 만든다.
5. DOM 트리와 CSSOM 트리를 결합하여 Render 트리를 만든다.
6. 레이아웃 과정을 통해 각 요소를 어디에 배치할지 결정한다.
7. 레이아웃 과정이 끝나면 UI 백엔드에서 Render 트리를 화면에 그린다.

<aside>
💡

파싱(Parsing)은 프로그래밍 언어의 코드를 실행하기 위해 구문분석(Syntax analysis)하는 것을 말한다. 인터프리터나 컴파일러 구성 요소 중 하나인 파서를 통해 파싱을 진행한다.

파서는 HTML 파일의 코드를 문법적 의미를 갖는 최소 단위인 토큰으로 분해하며 토큰들을 문법적 의미와 구조에 따라 노드라는 요소로 바꾼다.

- 브라우저가 코드를 이해하여 사용할 수 있는 구조로 변환하는 것을 문서 파싱이라고 한다. 렌더링 과정에서는 HTML 파일을 바탕으로 DOM 트리를 구축하고 및 CSS 파일로 CSSOM 트리를 만드는 것을 의미한다.

</aside>

### _DOM_

DOM(Document Object Model)이란 직역하면 HTML 문서를 객체화한 것으로 웹 문서의 구조화된 표현, XML, HTML 문서의 각 항목을 계층으로 표현하여 생성, 변형, 삭제할 수 있도록 돕는 인터페이스라고 할 수 있다. 생성, 변형, 삭제의 경우 API를 통해 프로그래밍 언어가 웹에 접근하여 조작할 수 있으며 이때 사용되는 프로그래밍 언어가 자바스크립트이다.

조금 더 자세히 설명하자면 요소 선택 또는 추가, 내용 변경, 속성 조작, 스타일 변경, 이벤트 처리 등의 API를 브라우저가 제공하고 정확히는 DOM API라고 한다. 이를 자바스크립트에서 사용하여 웹을 자유롭게 변형하는 것이다.

HTML 문서를 객체화한 것이라는 말처럼 DOM과 우리가 작성하는 HTML 문서는 서로 다르다. 브라우저가 HTML 문서를 번역하여 만들어낸 노드 트리가 DOM이다. DOM은 HTML과 자바스크립트를 이어주는 공간으로, 내가 작성한 HTML은 브라우저 입장에서 텍스트의 나열일 뿐이기에 브라우저가 이해할 수 있도록 객체(object)로 변환한 것이다.

HTML로부터 DOM이 생성되지만 경우에 따라 작성되지 않은 노드(태그)를 브라우저가 알아서 만들어 준다. 예를 들어 html태그 안에 head나 body 없이 작성하더라도 브라우저에서 열어보면 태그가 알아서 붙어있는 식이다.

### _DOM의 특징_

- 트리(Tree) 구조: DOM은 트리 구조로 표현되며 각 노드는 웹 페이지의 다양한 부분을 나타낸다. 다양한 부분이란 요소, 속성, 텍스트 등을 의미한다.
- 라이브(Live) 특성: DOM에 대한 변경은 즉시 웹페이지에 반영된다.
- 조작 가능: 자바스크립트를 사용하여 DOM 요소를 선택, 수정, 추가 또는 제거할 수 있다.

### _CSSOM_

CSS Object Model의 약자이다. HTML 파일을 DOM 트리로 파싱하는 과정에서 브라우저가 link나 style 태그를 만났을 때 파싱을 잠시 멈추고 해당 CSS 파일을 서버로 요청한다. 그 후 해당 파일을 파싱하여 CSSOM 트리를 만든다. CSSOM 트리를 구축하고 나면 브라우저는 다시 HTML 파일의 파싱을 멈췄던 부분으로 돌아가서 마저 DOM 트리를 구축한다.

### _Render Tree_

렌더링을 하기 위해서 서로 다른 속성을 가진 독립적인 트리인 DOM과 CSSOM 트리를 합치는 작업이다. 브라우저가 사용자에게 보여주려고 하는 화면을 그리는 과정이기에 사용자에게 보여주지 않아도 되거나 보여주지 말아야 할 태그나 요소는 렌더 트리에서 제외된다. DOM의 meta 태그나 CSSOM의 display:none이 대표적이다.

### _Layout_

렌더 트리를 기반으로 HTML 요소의 레이아웃(위치, 크기 등)을 계산하여 브라우저 화면 어디에 배치할지 결정하는 과정이다. 브라우저는 각 요소들이 전체 화면에서 어디에, 어떤 크기로, 어떻게 배치가 되어야 하는지 파악하기 위해 렌더 트리를 위에서 아래로 읽고 모든 값을 절대적인 단위인 px 값으로 변환한다.

### _Paint_

레이아웃에서 결정된 대로 브라우저가 화면에 출력하는 과정이다. 픽셀에 대한 정보들을 바탕으로 픽셀을 채워나가는 과정이다. 텍스트에 불과한 HTML 파일의 내용들이 이미지화된 모습으로 브라우저 화면에 띄워진다.

### _Reflow와 Repaint_

Reflow는 요소의 크기나 위치의 변경, 문서의 레이아웃 변경 등 페이지의 구조적 변경이 있을 때 웹 페이지의 레이아웃을 재계산하는 과정이다. Reflow는 계산이 복잡할 수 있고 브라우저가 페이지의 전체 레이아웃을 다시 계산해야 해서 성능에 영향을 준다. Reflow가 발생하면 Repaint도 발생하는 경우가 많다.

Repaint는 페이지의 스타일이나 색상과 같은 시각적 속성만 변경이 되었을 때 발생하는 과정이다. 레이아웃 계산을 하지 않고 색상이나 배경 같은 요소만 다시 그리는 작업을 수행하므로 Reflow보다 가벼운 작업이다.

매끄러운 UX 경험을 위해서는 브라우저가 1초 안에 60장 정도(60 프레임)의 레이아웃과 페인트 과정을 동시에 처리해야 한다. DOM이 변경되면 렌더 트리를 다시 구축해야 하기 때문에 변경될 때마다 리플로우와 리페인트를 거친다. 위에서 말했듯이 리플로우는 연상을 하기 때문에 CPU 자원을 많이 차지하게 된다. 리페인트도 리플로우보다는 적지만 GPU 자원을 사용하게 된다.

이런 문제를 해결하기 위해서는 리페인트만 발생시키는 속성을 사용하거나 불필요한 레이아웃을 줄이거나 JS와 CSS를 조합한 애니메이션의 노드에 대해 position을 absolute나 fixed를 사용해 영향을 받는 주변 노드들을 줄이는 방법 등이 있다.

# Virtual DOM

> Virtual DOM은 UI의 이상적인 또는 가상적인 표현을 메모리에 저장하고 React DOM과 같은 라이브러리에 의해 실제 DOM과 동기화하는 프로그래밍 개념

이라고 리액트에서 소개하고 있다.

Virtual DOM은 기존의 DOM 조작을 수행할 때 발생하는 비효율적인 렌더링 문제를 해결하고자 등장하게 되었다. 같은 맥락으로 SPA의 비율이 증가하면서 DOM을 직접 조작하는 경우가 증가하였고, 직접적인 DOM 조작으로 리플렉스나 리페인트가 발생해 성능의 하락을 야기할 수 있기에 virtual DOM을 통해 실제 DOM 조작을 최소화하여 성능을 최적화하게 된다. Virtual DOM은 실제 DOM의 가벼운 복사본으로 메모리 상에 존재하며 JS 객체 형태로 존재한다.

### _Diffing Algorithm and Reconciliation_

리액트는 항상 렌더링 이전의 화면 구조와 렌더링 이후의 화면 구조를 가진 두 개의 Virtual DOM 객체를 유지한다. 이 둘을 비교하여 변경된 부분만 실제 DOM에 반영하게 되며 이 과정에서는 diffing 알고리즘이 사용된다.

diffing 알고리즘은 이전 Virtual DOM 트리와 새로운 Virtual DOM 트리를 비교한 뒤 루트 노드에서 시작해, 이전과 새로운 노드를 비교한다. 두 노드가 다른 타입의 요소이면 이전 노드를 삭제 후 새 노드를 생성한다. 만일 같은 타입의 요소라면 속성을 비교하여 변경된 점이 있는지 확인한다. 변경된 속성이 없으면 그대로 사용하며 변경된 점이 있으면 업데이트하게 된다.

이후에는 자식 노드를 비교한다. 이때 Key를 기반으로 알고리즘을 적용한다. 리액트는 리스트가 변경되면 기본적으로 순차적 비교를 한다. 하지만 같은 부모를 가진 리스트의 요소가 추가 또는 삭제되면 효율적으로 처리하고자 Key 속성을 사용한다. Key가 있다면 해당 요소의 위치가 바뀌어도 리액트가 올바르게 판단하는 데에 도움을 주며 Key가 없다면 새 리스트와 이전 리스트를 1:1 대응하여 비교하기에 성능 저하가 발생할 수 있다. 참고로 Key의 경우 변동 가능한 값으로 사용하게 될 경우 불필요한 렌더링이 발생할 수 있기에 고유한 값으로 사용하는 것이 중요하다.

이렇게 diffing 알고리즘을 통해 변경 사항들을 Virtual DOM에 업데이트했다면 Reconciliation(재조정)을 통해 필요한 부분만을 최소한의 비용으로 실제 DOM에 업데이트한다. 이때 사용되는 것이 Batch Update이다. 배치 업데이트는 동시에 여러 개의 상태 업데이트를 한 번의 렌더링으로 처리하는 최적화 기법이다. 다만 0.1초마다 화면의 데이터가 변경될 경우 0.5초씩 모아서 렌더링하는 방식은 불가하다. “동시”에 변경된 상태는 한 번에 렌더링 되더라도 연속적인 변경은 각각의 렌더링이 발생하게 되는 것이다. 이 경우 다른 메서드나 기법을 사용하여 해결한다고 한다.

### _Virtual DOM의 한계_

위에서 언급한 경우 외에도 Virtual DOM에게도 한계가 존재한다. 예로 리액트를 사용한다고 무조건 빠르지 않다는 것이다. Virtual DOM은 최적화가 필요한 곳에서 유용하다. 무한 스크롤, 슬라이드 UI 같이 동적인 요소에 대해 Virtual DOM을 사용해 불필요한 렌더링을 줄이는 최적화를 하게 되는 것이지 컴포넌트가 많거나 상태 업데이트가 너무 자주 일어나게 되면 오히려 성능 저하가 발생할 수 있다. 경우에 따라서는 실제 DOM을 조작하는 경우보다 느릴 때도 있다.

또한 Virtual DOM의 경우 실제 DOM에 준하는 구조가 메모리에 존재하는 것이기에 메모리 사용량이 증가할 수밖에 없다. 따라서 컴포넌트가 많아지면 Virtual DOM이 커지고 렌더링마다 diffing 연산이 추가로 발생하기에 오버헤드가 발생할 수 있다.

그렇다고 해결 방법이 없는 것은 아니다. 자세히 알아본 것은 아니지만 각 한계점에 대한 최적화 기법을 사용하게 되면 문제를 해결할 수 있는 것으로 보이기에 이러한 한계점을 명심해 두고 필요할 때마다 최적화 기법을 적용하는 것이 좋은 선택이 될 것으로 보인다.

# MPA와 SPA

## MPA

MPA(Multiple Page Application)는 이름에서처럼 여러 개의 페이지로 구성된 웹 어플리케이션을 말한다. 주로 SSR 방식으로 렌더링하는, 새로운 페이지를 요청할 때마다 서버에서 렌더링 된 HTML을 받아오는 전통적인 방식이다. 페이지를 이동할 때마다 새로고침이 발생하며 새로고침하게 되면 전체 페이지를 다시 렌더링한다.

### _MPA 장점_

페이지마다 필요한 리소스만 로드하기에 초기 로딩 속도가 빠른 편이다. MPA를 사용하여 여러 페이지를 생성할 수 있기 때문에 많은 키워드를 타겟팅할 수 있다. 구글에서 얻을 수 있는 유기적 트래픽의 양이 향상되며, HTML을 다운로드하여 크롤링하는 검색 엔진에 대해 아무래도 페이지가 많은 것이 SEO에 유리할 수밖에 없다. 원하는 만큼 페이지를 추가할 수 있기도 하다.

### _MPA 단점_

새로운 페이지로 이동할 때마다 전체 페이지를 다시 렌더링 하기 때문에 페이지 전환 속도가 느리다. 또한 클라이언트와 서버 모두에 프레임워크를 사용해야 하기에 복잡한 개발이 진행되며 페이지의 개수가 많아 모든 페이지의 안정성 검사와 같은 지속적인 유지보수가 쉽지 않다. 물론 여느 단점들처럼 무조건 MPA가 더 느린 것도 아니며 최적화를 통해 어느 정도 개선할 수 있는 부분이 있다.

## SPA

SPA(Single Page Application)는 초기 한 번만 HTML을 로드하고 이후에는 JS를 통해 동적으로 화면을 변경하는 방식이다. 페이지 이동 시 새로고침 없이 콘텐츠만 변경이 되는 특징이 있으며 새로운 페이지 요청 시 백엔드 API 서버와 통신하여 페이지 갱신에 필요한 데이터만을 JSON으로 받아 화면을 변경한다. 이때 AJAX, Fetch, Axios 등을 사용한다.

SPA의 핵심 가치는 사용자 경험의 향상에 있으며 부가적으로 어플리케이션 속도 향상을 기대할 수 있어 모바일 퍼스트 전략에 부합한다.

### _SPA 장점_

전체 페이지를 다시 렌더링하지 않고 변경되는 부분만 갱신하기에 네이티브 앱과 유사한 사용자 경험을 제공할 수 있다. 모바일 앱도 SPA와 동일한 아키텍처에서 개발되므로 모바일 개발을 염두에 두면 동일한 백엔드 코드를 재사용할 수도 있다. 또한 서버에서 페이지를 렌더링하기 위한 코드를 작성하지 않아도 되어 개발의 간소화가 이루어지며, 로컬 스토리지를 효과적으로 캐시할 수도 있다.

### _SPA 단점_

웹 어플리케이션에 필요한 모든 정적 리소스를 한 번에 다운로드하기 때문에 초기 구동 속도가 상대적으로 느리다. SPA는 JS로 구축되는데, SPA에 주로 사용되는 CSR 방식의 자바스크립트를 읽지 못하는 검색엔진에 크롤링 되지 않아 SEO 이슈가 생길 수 있다. 물론 요즘 구글 크롤러가 개선되어 이전보다는 괜찮지만 확실한 SEO를 위해서는 SSR이나 SSG 방식을 사용하는 것이 일반적이다.

# CSR과 SSR

렌더링에도 여러 방식이 존재한다. 방식에 따라 로딩 속도, 검색 엔진 최적화, 사용자 경험 등이 달라질 수 있다. 렌더링 방식에는 클라이언트 사이드 렌더링(Client Side Rendering, CSR), 서버 사이드 렌더링(Server Side Rendering, SSR), 정적 사이트 생성(Static Site Generation, SSG), 증분 정적 재생성(Incremental Static Regeneration, ISR)이 있다.

## CSR

웹 브라우저에서 JS를 사용하여 웹페이지를 렌더링하는 방식이다. 사용자의 브라우저가 서버로부터 데이터를 받아와 직접 웹 페이지를 생성하는 것이다. 브라우저의 성능이 좋으면 웹 페이지의 렌더링 속도도 빠르고 사용자 경험이 좋아지지만 브라우저 성능이 낮거나 JS를 지원하지 않는 경우라면 웹 페이지의 렌더링 속도가 느려지거나 제대로 표시되지 않는 경우가 생길 수 있다.

사용자와의 상호작용이 많은 웹사이트에 적합하며 대시보드, 관리자 페이지처럼 사용자의 입력에 따라 화면이 동적으로 변하는 경우, SEO가 중요하지 않은 경우 활용할 수 있다.

### _CSR 동작과정_

1. 사용자가 웹사이트에 접속하면 서버는 빈 HTML과 JS 파일을 보낸다.
2. 브라우저가 JS를 로드하고 실행한다.
3. JS가 동적으로 HTML을 생성하고, 이를 브라우저에 표시한다.
4. 추가 페이지 요청 시 전체 페이지를 다시 로드하는 대신 필요한 데이터만 서버에서 받아와 해당 부분만 업데이트한다.

### _CSR 장점_

초기 로딩 후 서버에서 필요한 데이터만 가져와 동적으로 페이지를 업데이트하기 때문에 추가 페이지 로딩이 없다. 이로 인해 사용자와의 인터렉션이 빠르게 이루어진다. 또한 전체 페이지를 매번 렌더링 하는 것이 아닌, 변화가 있는 부분만 업데이트하여 서버에 부담을 줄여준다.

### _CSR 단점_

브라우저가 JS를 로드하고 실행하는 과정이 필요하여 초기 로딩 속도가 느릴 수 있다. 또한 브라우저가 JS를 실행하여 동적으로 페이지를 만들기 때문에 이 과정이 이뤄지기 전에는 빈 HTML이 화면에 먼저 보이게 된다. 이 때문에 웹 크롤러가 페이지의 내용을 제대로 인식하지 못해 SEO에 불리할 있다.

## SSR

서버에서 HTML을 만들어 브라우저로 보내는 방식이다. 동적 컨텐츠가 많은 웹사이트에 적합하며 콘텐츠가 사용자의 요청에 따라 실시간으로 변경되어야 하는 경우 적합하며, 서버에서 렌더링을 통해 항상 최신 상태의 웹 페이지를 제공할 수 있다. 주식 정보나 사용자 맞춤형 콘텐츠를 제공하는 웹사이트 등 실시간으로 변경되는 데이터를 다루는 웹사이트에서 활용하기 좋다.

### _SSR 동작과정_

1. 사용자가 웹사이트에 접속하면 서버에서 해당 페이지에 필요한 HTML을 생성한다.
2. 서버는 생성된 HTML을 브라우저로 보낸다.
3. 브라우저가 HTML을 표시한다.
4. 추가 페이지 요청 시 해당 페이지에 대한 HTML을 다시 서버에서 생성하여 보낸다.

### _SSR 장점_

서버에서 완성된 HTML을 브라우저로 보내주기에 초기 페이지 로딩이 빠르며 완성된 HTML을 제공하기에 검색 엔진이 콘텐츠를 쉽게 인식하고 인덱싱할 수 있다.

### _SSR 단점_

사용자의 요청마다 서버에서 렌더링을 해야 하기에 서버의 부하가 상대적으로 커질 수 있다.

## SSG

빌드 시 모든 페이지를 HTML로 미리 생성하는 방식이다. 내용이 자주 변경되지 않는 웹사이트에 적합하며 회사 소개, 제품 소개, 블로그 등 콘텐츠가 일정 시간 동안 고정되는 경우 사용 가능하다.

### _SSG 동작 과정_

1. 빌드 시, 서버는 모든 가능한 요청에 대한 HTML을 미리 생성한다.
2. 사용자가 웹사이트에 접속하면 서버는 미리 생성해둔 HTML을 보낸다.
3. 브라우저는 받은 HTML을 표시한다.
4. 추가 페이지 요청 시 미리 생성해둔 해당 페이지의 HTML을 보낸다.

### _SSG 장점_

모든 페이지가 빌드 시에 미리 생성되므로 사용자 요청에 대해 빠른 로딩 속도를 제공한다. 미리 생성된 HTML만 제공하기에 서버 부하가 적다.

### _SSG 단점_

사이트의 데이터가 변경될 때마다 전체 사이트를 다시 빌드해야 한다.

## ISR

SSG와 SSR의 단점을 보완하고 장점을 결합한 Next.js 프레임워크에서 도입한 렌더링 방식이다. 빌드 시점에서 페이지를 미리 생성하면서도 특정 시간 간격으로 페이지를 재생성하여 업데이트된 데이터를 반영할 수 있다. 따라서 일부 페이지는 자주 업데이트 되고, 다른 일부 페이지는 그렇지 않은 경우 사용할 수 있다.

### _ISR 동작 과정_

1. 빌드 시점에 웹 페이지를 정적으로 생성한다. Next.js에서는 getStaticProps와 revalidate 옵션을 이용하여 페이지를 어떻게 생성하고 언제 생성할지 설정할 수 있다.
2. 웹 사이트에 접속하면 미리 생성된 HTML을 보낸다.
3. 브라우저는 받은 HTML을 표시한다.
4. 새로운 사용자의 요청이 들어왔을 때 revalidate 옵션에 설정된 시간이 경과되면 해당 페이지를 서버에서 재생성한다. 이때 설정된 시간이 경과되어도 새로운 요청이 없으면 페이지를 재생성하지 않아 새로 들어온 사용자는 이전 페이지를 보게 된다. 따라서 새로운 요청이 있을 때에만 페이지가 재생성되며 재생성 중에는 이전의 페이지가 계속해서 보이게 된다.

### _ISR 장점_

페이지가 미리 생성되어 있어 즉시 응답할 수 있으며, 정해진 시간 간격으로 새로운 요청이 들어오면 페이지를 재생성하기 때문에 데이터의 변경을 반영할 수 있다. 모든 요청에 대해 실시간으로 페이지를 생성하지 않아 서버 부하를 줄일 수 있다.

### _ISR 단점_

각 페이지의 상태를 관리해야 하기 때문에 구현이 복잡할 수 있으며 페이지의 재생성에 시간이 소요되므로 빈번하게 변경되는 데이터는 반영하기 어려울 수 있다.
