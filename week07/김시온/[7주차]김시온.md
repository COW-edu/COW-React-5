# 7주차 세션

---

- [✅] todo 목록을 볼 수 있습니다.
- [✅] todo 추가 버튼을 클릭하면 할 일이 추가됩니다.
- [✅] todo 완료 버튼을 누르면 완료 되었다는 표시가 됩니다.
- [✅] todo 수정 버튼을 누르면 수정 모드로 들어가고, 수정 내용을 제출하거나 수정 모드를 취소할 수 있습니다.
- [✅] todo 삭제 버튼을 누르면 해당 할 일이 삭제됩니다.
- [✅] 수정되는 Todo 내용이 실시간으로 반영됩니다.

---

📚 학습 주제
동기 처리 비동기 처리 , axios fetch , REST API

# 동기와 비동기

## 동기(Synchronous)

동기(Synchronous)는 작업을 순차적으로 실행함을 의미

### 동기의 특징

- 한 작업이 완료될 때까지 다음 작업은 대기한다. 이를 있어 보이는 말로 직렬적으로 task를 수행한다고 한다.
- 순차적으로 실행되어 구현이 상대적으로 직관적이고 간단하다.
- 해당 작업이 완료될 때까지 다음 작업이 대기해야 하는 만큼 시스템의 전체적인 효율이 저하될 수 있다. 이를 전문용어로 Blocking이라고 한다.

  ```jsx
  function greetUser() {
    const name = prompt('이름을 입력하세요:');
    console.log(`안녕하세요, ${name}님!`);

    const num1 = parseInt(prompt('첫 번째 숫자를 입력하세요:'), 10);
    const num2 = parseInt(prompt('두 번째 숫자를 입력하세요:'), 10);

    const sum = num1 + num2;
    console.log(`두 숫자의 합은 ${sum}입니다.`);
  }

  greetUser(); // 해당 함수 내의 코드들은 위에서 아래로 차례대로 작동된다.
  console.log('blocking됨'); // 위 함수에서 prompt에 입력을 하지 않아
  // 코드의 진행이 되지 않는다면 해당 출력문은 브라우저에 뜰 수 없다. (blocking)
  ```

## 비동기(Asynchronous)

비동기(Asynchronous)는 여러 작업을 동시에 처리함을 의미

### 비동기의 특징

- 동기와는 다르게 현재 코드가 끝날 때까지 코드의 실행을 멈추지 않고 다음 코드를 실행한다. 있어 보이는 말로 병렬적으로 task를 수행한다고 한다.
- 동시에 여러 작업을 처리할 수 있어 시간이 오래 걸리는 작업을 효율적으로 처리할 수 있다.
- 동시에 진행되는 코드들을 잘 다뤄야 하기 때문에 코드의 복잡성이 증가할 수 있다.
- 비동기 요청 시 응답 후 처리할 콜백함수를 함께 알려준다. 말 그대로 해당 작업이 완료되었을 때 콜백함수가 호출된다.

<aside>
💡

콜백함수란 어떤 함수의 인자로 들어가는 함수이다. JS에서 함수는 객체이기에 다른 객체들처럼 함수의 인자로 사용될 수도 있고 반환 될 수도 있다. 이런 함수를 고차함수라고 한다. 아무튼 함수의 인자로 사용되는 함수가 콜백 함수이다.

단지 함수를 등록하기만 하고 어떤 이벤트가 발생하거나 특정 시점에 도달했을 때 시스템에서 호출하게 된다. 비동기 상황에서 유용하게 사용된다.

```jsx
function func(callback) {
  // 함수의 인자로 함수가 들어간다.
  callback();
}
function callback() {
  console.log('callback이다');
}

func(callback); // 결과 : callback이다
```

```jsx
function introduce (lastName, firstName, callback) {
	var fullName = lastName + firstName;
	callback(fullName);
}
// 인자로 어떤 인자를 콘솔에 출력하는 익명 함수를 "작성"했다.
// 이 경우 introduce에서 정의한 callback이 익명함수로 대체되어
// name이라는 인자에 대해 callback에 정의한 fullname이 들어가게 된다.
introduce("홍", "길동", function(name) {
	console.log(name);
    }; // 결과 -> 홍길동
```

```jsx
function findUser(id) {
  // 비동기 함수와 함께 콜백함수를 사용하지 않을 때
  let user;
  setTimeout(function () {
    console.log('waited 0.1 sec.');
    user = {
      id: id,
      name: 'User' + id,
      email: id + '@test.com',
    };
  }, 100);
  return user;
}

const user = findUser(1);
console.log('user:', user);

// 결과
// user: undefined
// waited 0.1 sec.

//-> setTimeout이 비동기로 처리하는 객체 생성을 기다리지
// 않고 바로 return해버려 undefined가 나왔다.
```

```jsx
function findUserAndCallBack(id, cb) {
  // 비동기와 콜백 함께 사용
  setTimeout(function () {
    console.log('waited 0.1 sec.');
    const user = {
      id: id,
      name: 'User' + id,
      email: id + '@test.com',
    };
    cb(user);
  }, 100);
}

findUserAndCallBack(1, function (user) {
  console.log('user:', user);
});

// 결과
// waited 0.1 sec.
// user: {id: 1, name: "User1", email: "1@test.com"}

// -> setTimeout에 입력된 함수가 실행된 뒤에 콜백함수가 실행되어
// user의 정보가 정상적으로 출력되었다.
// 여기서 추가로 알 수 있는 점은, 콜백함수를 적절히 사용하면
// return을 하지 않을 수 있다는 것이다.
```

</aside>

- 다만 비동기 처리에서 순서의 보장을 위해 콜백 패턴을 사용할 때 콜백함수가 중첩되어 복잡도(알고리즘에서의 시간 복잡도와는 다르게 가독성, 유지보수성, 구조적 복잡함을 의미)를 무진장 높이는 콜백 헬이 발생할 수 있다.

  ```jsx
  function call(name, cb) {
    setTimeout(function () {
      console.log(name);
      cb(name);
    }, 1000);
  }
  function back(cb) {
    setTimeout(function () {
      console.log('back');
      cb('back');
    }, 1000);
  }
  function hell(cb) {
    setTimeout(function () {
      cb('callback hell');
    }, 1000);
  }

  call('Lee', function (name) {
    // 콜백 안에 콜백 안에 콜백 안에...
    console.log(name + '반가워');
    back(function (txt) {
      console.log(txt + '을 실행했구나');
      hell(function (message) {
        console.log('여기는 ' + message);
      });
    });
  });

  // 결과
  // Lee
  // Lee반가워
  // back
  // back을 실행했구나
  // 여기는 callback hell
  ```

## Promise, Async, Await

### Promise

콜백 패턴을 사용한다고 해서 여러 개의 비동기 처리를 한 번에 처리하는 데에도 한계가 있었다.

때문에 ES6에서 비동기 처리를 위한 또 다른 패턴으로 Promise를 도입했다. 프로미스를 사용하면서 콜백 패턴이 가진 문제점들을 보완하면서 비동기 처리 시점을 명확하게 표현할 수 있게 되었다.

Promise는 비동기 처리의 성공(fullfilled)이나 실패(rejected) 등의 상태(state)를 갖는다. 리액트같은 프레임워크에서 비동기 상태에 따라 UI를 변경할 때 상태들을 분기 처리할 수 있다.

- pending : 비동기 처리가 아직 수행되지 않은 상태
- fulfilled : 비동기 처리가 수행된 상태 (성공)
- rejected : 비동기 처리가 수행된 상태 (실패)
- settled : 비동기 처리가 수행된 상태 (성공 또는 실패)

  ```jsx
  const p = new Promise((resolve, reject) => {
    // 비동기 처리 중
    setTimeout(() => {
      resolve('성공!');
    }, 1000);
  });

  console.log(p);
  // 당장에는 pending 상태
  // 1초가 지나면 fulfilled로 변경
  ```

### Promise 호출

1. Promise 생성자 함수를 통해 Promise 객체를 생성(인스턴스화)하고 그 내부에서 비동기 처리를 구현한다. Promise 생성자 함수는 비동기 작업을 수행할 콜백함수를 인자로 전달 받고, 콜백함수는 resolve와 reject를 인자로 전달 받게 된다.
2. 비동기 작업이 성공하면 resolve라는 메서드를 호출한다. resolve 메서드의 인자로 비동기 처리 결과를 전달하면 Promise의 뒤에 오는 메서드(then)로 전달된다.
3. 비동기 작업이 실패하면 reject 메서드를 호출한다. reject 메서드의 인자로는 에러 메시지를 전달한다. 비슷하게 뒤에 오는 메서드(catch)로 전달된다.

- resolve(value) : 작업이 성공적으로 끝난 경우에 value가 프로미스를 실행한 곳의 then으로 들어간다.
- reject(error) : 에러 발생 시 프로미스를 실행한 곳의 catch로 error가 들어간다.
- then : 앞의 Promise에서 비동기가 성공한 경우와 실패한 경우에 작동할 수 있는 두 개의 콜백 함수를 각각 첫 번째 인자와 두 번째 인자로 전달 받을 수 있다. 다만 실패의 경우 catch를 주로 사용한다. return으로 Promise를 작성하면 다음 then에서는 Promise가 resolve될 때까지 기다렸다가 resolve된 결과를 전달 받고, 단순한 값이나 undefined를 return하면 그 값이 그대로 다음 then으로 전달되며, 아무것도 return하지 않으면 undefined를 자동으로 넘긴다.
- catch : Promise나 then에서 에러가 발생하면 호출되며 에러를 인자로 받는다.
- Promise 체이닝 : 기존의 콜백 패턴에서 발생하는 콜백 헬 현상을 해결하기 위해 등장한 개념. 프로미스는 후속 처리 메서드인 then이나 catch로 메서드들을 체이닝하여 여러 프로미스를 연결하여 사용할 수 있다. 객체의 메서드 사용방식처럼 “.”을 사용하여 연결한다.

```jsx
// Promise 객체의 생성
const func1 = new Promise((resolve, reject) => {
  // 프로미스 내에서의 작업은 비동기적으로 수행된다.
  flag = true;
  if (flag) resolve('성공');
  else reject('실패');
});

//func1 실행값이 then에 들어온다.
func1
  .then((value) => {
    return value + '1';
  })
  .then((result) => {
    //첫번째 then에서 리턴된 값이 여기 온다.
    console.log(result);
  })
  .catch((err) => {
    // 에서 발생 시 catch 안의 콜백 함수가 실행 된다.
    console.log(err);
  });

// 결과
// 성공1
```

```jsx
// 이전에 작성한 콜백 헬 코드를 Promise로 작성하면 아래와 같다.
function call(name) {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      console.log(name);
      resolve(name);
    }, 1000);
  });
}

function back() {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      console.log('back');
      resolve('back');
    }, 1000);
  });
}

function hell() {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      resolve('promise');
    }, 1000);
  });
}

call('Lee')
  // then은 Promise를 반환받을 때 Promise가 완료될 때까지 기다렸다가 완료되면 작동한다.
  .then(function (name) {
    console.log(name + '반가워');
    return back();
  })
  .then(function (txt) {
    console.log(txt + '을 실행했구나');
    return hell();
  })
  .then(function (message) {
    console.log('여기는 ' + message);
  });
```

### Async / Await

둘 다 비동기 처리 패턴에서 가장 최근에 나왔다고 한다. 프로미스의 단점까지도 보완하고 개발자 지향적인 코드를 작성하게 도와준다.

### async 문법

```jsx
async function 함수명() {
  await 비동기_처리_메서드_명(); // 항상 await를 사용하라는 의미는 아니다.
}
```

### async 개념

async 키워드는 function 앞에 사용한다. async를 사용하면 해당 함수는 항상 프로미스를 반환한다. 프로미스가 아닌 값을 반환하더라도 이행 상태의 프로미스(내부적으로 Promise.resolve(값)이 호출된 상태의 프로미스)로 값을 감싸 이행된 프로미스가 반환되도록 한다.

```jsx
function normalFn() {
  return '안녕';
}

async function asyncFn() {
  return '안녕';
}

console.log(normalFn()); // → "안녕"
console.log(asyncFn()); // → Promise { "안녕" }
```

```jsx
async function hello() {
  return 'Hi';
}

// 명시적으로 Promise.resolve 하는 것과 같다.
function hello2() {
  return Promise.resolve('Hi');
}
```

### await 개념

async 함수 안에서만 작동한다. “기다리다”라는 단어의 뜻처럼 프로미스가 처리될 때까지 기다리는 역할을 한다. 프로미스가 처리되길 기다리는 동안에도 엔진이 다른 일들을 할 수 있어서 CPU 리소스가 낭비되지 않는다.

awit가 던진 에러를 잡을 때에는 throw가 던진 에러를 잡을 때처럼 try catch를 사용하면 된다.

```jsx
// Promise를 사용한 경우
function fetchData() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve('✅ 데이터 받아옴!');
    }, 2000); // 2초 후 데이터 반환
  });
}

function getDataAndPrint() {
  console.log('1️⃣ 데이터를 요청합니다...');

  fetchData()
    .then((result) => {
      console.log('2️⃣ 응답:', result);
    })
    .then(() => {
      console.log('3️⃣ 모든 작업 완료!');
    });
}

getDataAndPrint();
```

```jsx
// async와 await를 사용한 경우
function fetchData() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve('✅ 데이터 받아옴!');
    }, 2000); // 2초 후 데이터 반환
  });
}

async function getDataAndPrint() {
  console.log('1️⃣ 데이터를 요청합니다...');

  const result = await fetchData(); // fetchData()가 끝날 때까지 기다림
  console.log('2️⃣ 응답:', result);

  console.log('3️⃣ 모든 작업 완료!');
}

getDataAndPrint();
```

위의 코드를 보면 result라는 변수에서 fetchData()에 대한 값을 받을 때 await를 사용하였다. 이는 getDataAndPrint()가 async로 선언되어 있기에 사용 가능했던 것이며 await로 인해 2초 동안 기다린 후 fetchData()에서 값을 받아온다.

결국 await를 사용하게 되면서 비동기를 동기처럼 다룰 수 있게 되었다. 또한, Promise를 사용했을 때보다 일반적인 코드를 작성하는 것처럼 작성할 수 있어서 보다 직관적인 비동기 코드 작성이 가능해졌다. (읽기도 편하다.)

## 동기와 비동기, 언제 쓰는 게 좋은가

### 동기가 적합한 경우

- 작업의 순서가 중요할 때
- 각 단계의 결과가 다음 단계에 즉시 필요할 때
- 간단한 스크립트나 작은 규모의 프로그램

### 비동기가 적합한 경우

- 네트워크 요청이나 파일 I/O와 같은 시간이 오래 걸리는 작업을 처리할 때
- 여러 독립적인 작업을 동시에 처리해야 할 때
- 사용자 인터페이스의 반응성을 유지해야 할 때
- 대규모 동시성이 필요한 서버 어플리케이션

# Axios와 Fetch

이 둘은 클라이언트와 서버 간의 데이터를 주고 받는 비동기 HTTP 통신(요청을 보내고 요청에 대한 응답을 받는 대화)을 하기 위해 사용되는 문법이다. 사용법이나 기능은 비슷하지만 각각의 장단점이 존재한다.

## Axios

Node.js와 브라우저를 위한 Promise API를 활용하는 HTTP 통신 외부 라이브러리이다. 비동기로 HTTP 통신을 할 수 있고 Promise 객체를 return 해주기 때문에 response 데이터를 다루기 쉽다.

- 장점
  - JSON 자동 변환 / 자동 문자열 변환 / CSRF 보호 기능 등 fetch에는 없는 비교적 다양한 기능들이 존재한다.
  - Axios를 사용하면 기본적으로 응답 데이터를 JSON 타입으로 받을 수 있다. 따라서 응답 데이터는 응답 객체의 data 속성으로 접근 가능하다.
  - Promise API (Promise 객체를 만들고, 처리하고, 결과를 다루는 방법을 제공하는 기능들을 통틀어 말함)를 활용하기 때문에 다루기 편리하다.
  - 브라우저 호환성이 뛰어나다
- 단점
  - 별도의 라이브러리 설치가 필요하다.
  - 외부에서 가져오는 것이기에 업데이트에 따라 불안정적일 수 있다.

### 문법 구성

1. axios 설치하기

   `npm install axios`

2. **axios 문법구성**

   ```jsx
   axios(url, {
     method: 'GET', // 요청 방식 (GET, POST, PUT, DELETE 등)
     headers: {
       // 헤더 설정
       'Content-Type': 'application/json',
     },
     params: {
       // URL 쿼리 파라미터 (GET 요청에 사용)
       userId: 1,
     },
     data: {
       // 요청 본문 (POST, PUT 등에서 사용)
       name: 'Lee',
       age: 25,
     },
     timeout: 5000, // 응답 시간 제한 (ms 단위, 여기선 5초)
   });
   // ==========================================================
   axios.get(url, {
     // HTTP 메서드를 바로 붙여 쓸 수도 있다.
     // 설정 옵션
   });
   // ==========================================================
   axios(url); // -> 설정이 없으면 기본적으로 GET 요청을 생성함
   // ==========================================================
   axios({
     method: 'GET',
     url: 'https://example.com/data', // url을 세부 설정에서 다룰 수도 있다.
     headers: {
       /* ... */
     },
     params: {
       /* ... */
     },
     timeout: 5000,
   });
   ```

   ```jsx
   import axios from 'axios';

   const getData = async () => {
     try {
       const response = await axios({
         method: 'get',
         url: 'https://jsonplaceholder.typicode.com/posts/1',
       });

       console.log(response); // 전체 응답
       console.log(response.data); // 실제 데이터
     } catch (error) {
       console.error('에러 발생:', error);
     }
   };
   ```

- Axios에서 설정 옵션에 사용할 수 있는 옵션 목록은 다음과 같다.

| 옵션              | 설명                                                     |
| ----------------- | -------------------------------------------------------- |
| `headers`         | 요청 헤더 설정 (`Content-Type`, `Authorization` 등)      |
| `params`          | URL 쿼리 파라미터 (`?key=value`)                         |
| `timeout`         | 요청 제한 시간 (ms 단위)                                 |
| `withCredentials` | 쿠키 포함 여부 (CORS 요청 시 유용)                       |
| `auth`            | HTTP 기본 인증 {username, password}                      |
| `responseType`    | 응답 데이터 타입 (`json`, `blob`, `text`, 등)            |
| `baseURL`         | 요청 기본 주소 설정 (여러 요청에 같은 도메인 쓸 때 편리) |

## Fetch

Promise 기반 JS 내장 라이브러리이다.

- 장점
  - JS 내장 라이브러리이기에 별도 설치가 필요 없다.
  - Promise API를 사용하기에 다루기 편리하다.
  - 내장 라이브러리이기 때문에 업데이트에 따른 오류 예방이 가능하다.
- 단점

  - 지원되니 않는 브라우저가 존재한다. (IE…)
  - 네트워크 에러 발생 시 response timeout이 없어 계속 기다려야 한다. → Fetch API가 자동으로 응답 시간 초과를 감지하지 못하여 AbortController로 구현한다.

    ```jsx
    const url = 'https://jsonplaceholder.typicode.com/posts/1';

    const controller = new AbortController();
    const signal = controller.signal;
    setTimeout(() => controller.abort(), 4000);

    fetch(url, {
      signal: signal,
    })
      .then((response) => response.json())
      .then(console.log)
      .catch((err) => {
        console.error(err.message);
      });
    ```

  - JSON 변환, 문자열 변환 과정이 별도로 필요하다. (Axios와 달리 HTTP 요청의 응답을 나타내는 \*\*\*\*Response 객체르 반환하기에 JSON 타입이 반환되지 않아 .json() 메서드 사용이 필요하다. Response 객체는 서버가 보내준 응답 전체를 감싸고 있는 가공되지 않은 객체이다.)
  - axios에 비해 비교적 기능이 부족하다.

### 문법

Fetch는 두 개의 인자를 받는다. 첫 번째 인자는 가져오고자 하는 리소스의 URL이고 두 번째 인자는 요청의 설정 옵션을 포함하는 객체로 선택적 인자인다.

만일 두 번째 인자를 작성하지 않으면 기본적으로 GET 요청을 생성한다.

`fetch(url);`

```jsx
fetch(url, {
  method: 'GET', // HTTP 메서드 (GET, POST, PUT, DELETE 등)
  headers: {
    // 요청 헤더
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    // 요청 본문 (POST나 PUT일 때 주로 사용)
    key: 'value',
  }),
  mode: 'cors', // CORS 정책: cors, no-cors, same-origin
  credentials: 'include', // 쿠키 포함 여부: omit, same-origin, include
  cache: 'no-cache', // 캐시 정책
  redirect: 'follow', // 리디렉션 정책
  referrerPolicy: 'no-referrer', // 리퍼러 정책
});
```

```jsx
const getData = async (e) => {
  try {
    const response = await fetch('API통신을 위한 url', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        // axios는 자동으로 데이터를 JSON 문자열로 직렬화해주지만
        // fetchs는 안 되기 때문에 직접 stringfy를 사용하여
        // 객체를 JSON 문자열로 변환하여 할당해야 함.
        id: 'id',
        description: 'description',
      }),
    });

    const data = await response.json(); // ← 여기서 JSON으로 변환, Promise 반환
    console.log(data); // 이제 응답 데이터를 출력
  } catch (error) {
    console.error('에러 발생:', error);
  }
};
```

- Fetch에서 설정 옵션에 사용할 수 있는 옵션 목록은 다음과 같다.
  | 옵션 | 설명 |
  | ---------------- | ------------------------------------------------- |
  | `method` | HTTP 요청 방식 (기본값 : “GET”) |
  | `headers` | 요청 헤더 설정(예 : Content-Type, Authorization) |
  | `body` | 요청 본문 (문자열이어야 함, 보통 JSON.stringfy()) |
  | `mode` | CORS 설정 (”cors”, “no-cors”, “same-origin”) |
  | `credentials` | 쿠키 전송 여부(”omit”, “same-origin”, “include”) |
  | `cache` | 캐시 설정 (”default”, “no-cache”, “reload” 등) |
  | `redirect` | 리디렉션 처리 방식 (”follow”, “manual”, “error”) |
  | `referrerPolicy` | 리퍼러 헤더 전송 정책 |

# REST API

## REST API 등장 배경

REST API는 REST 아키텍처 스타일의 설계 원칙을 따르는 어플리케이션 프로그래밍 인터페이스 (Application Programming Interface)를 말한다. REST는 Representational State Transfer의 줄임말로, 인터넷과 같이 복잡한 네트워크 통신이 등장하면서 이를 관리하기 위한 지침으로 등장했다. 대부분의 비즈니스 어플리케이션은 다양한 작업을 수행하기 위해 다른 내부 어플리케이션 및 서드 파티 어플리케이션과 통신해야 했다.

> 최근의 서버 프로그램은 다양한 브라우저와 안드로이드폰, 아이폰과 같은 모바일 디바이스에서도 통신을 할 수 있어야 한다. 이러한 멀티 플랫폼에 대한 지원을 위해 서비스 자원에 대한 아키텍처를 세우고 이용하는 방법을 모색한 결과 REST에 관심을 가지게 되었다.

REST 기반 아키텍처를 사용하여 대규모의 고성능 통신을 안정적으로 지원할 수 있게 되었고 모든 API 시스템을 파악하고 여러 플랫폼에서 사용할 수 있게 되었다.

## API란

프로그램끼리 서로 소통할 수 있게 해주는 약속된 규칙 또는 인터페이스라고 할 수 있겠다. API의 종류에는 Web API, Browser API, Library API 등이 있다.

- Web API : 웹 서버와 통신하는 API
- Browser API : 브라우저에서 제공하는 기능 ex. navigator.geolocation
- Library API : 라이브러리나 프레임워크가 제공하는 함수들의 모음

Web API의 진행 방식은 클라이언트 → HTTP 요청 → API 서버로 진행되었다가 다시 API 서버 → HTTP 응답 (JSON 데이터 등) → 클라이언트의 순서로 진행된다.

## REST란

**자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든 것을 의미한다.** 어떻게 보면 웹에서 자원을 어떻게 명확하고 일관되게 요청하고 응답할지 정해둔 방식이라고도 할 수 있겠다.

HTTP URI (Uniform Resource Identifier)를 통해 자원을 명시하고 HTTP 메서드를 통해 해당 자원(URI)에 대한 CRUD Operation을 적용한다.

- 자원의 이름으로 구분한다는 것은 자원을 이름으로 표현하는 REST의 방식을 나타낸다.
  - 자원이라 함은 문서, 사진, 데이터 등 소프트웨어가 관리하는 모든 것을 의미한다. 예로 들어 DB의 영화 정보가 자원일 때 /movie를 자원의 표현으로 정할 수 있다.
- 자원의 상태를 주고 받는다는 의미는 요청이 있으면 응답으로 받는 것을 말한다.
  - 클라이언트는 데이터가 요청되어지는 시점에서 자원의 상태(정보, payload)를 전달한다.
  - 클라이언트가 자원의 상태에 대한 조작을 요청하면 서버는 이에 대한 적정한 응답(Representation)을 보낸다. 이때 전달 방식으로는 JSON이나 XML을 통해 주고 받는 것이 일반적이다.

⇒ REST는 HTTP URI를 통해 클라이언트와 서버가 통신하는 방식 중 하나로 HTTP 메서드를 통해 자원을 처리(CRUD)하도록 설계된 아키텍처를 의미한다.

## REST의 구성 요소

- **리소스(자원, Resource) - HTTP URI**
  - 우리가 다루는 대상 (게시글이든 사용자든 댓글이든)
  - REST에서 자원은 고유한 URI(Uniform Resource Identifier)로 식별됨
  - 자원은 서버에 존재하며, 클라이언트는 이 자원에 접근하거나 조작하기 위해 URI를 사용한다.
    - `/groups/123`와 같은 URI는 `group_id`가 123인 그룹이라는 특정 자원을 나타낸다.
  - 클라이언트는 URI로 자원을 지정하고, HTTP 메서드(GET, POST, PUT, DELETE 등)를 이용해 자원의 상태를 조회하거나 변경할 수 있다
- **행위(Verb) - HTTP Method**
  - REST에서는 자원(Resource)에 대한 행위를 HTTP 메서드로 표현한다.
  - HTTP는 다음과 같은 주요 메서드를 제공한다:
    | 메서드 | 설명 | 예시 |
    | -------- | ---------------- | --------------- |
    | `GET` | 자원 조회 | GET /posts |
    | `POST` | 자원 생성 | POST /posts |
    | `PUT` | 자원의 전체 수정 | PUT /posts/1 |
    | `PATCH` | 자원의 부분 수정 | PATCH /posts/1 |
    | `DELETE` | 자원의 삭제 | DELETE /posts/1 |
- **표현 (Representation of Resource)**
  - 클라이언트가 자원의 상태에 대한 조작을 요청하면, 서버는 이에 대한 결과를 응답으로 돌려준다
  - 이때 서버는 자원의 상태를 표현(Representation) 형태로 반환한다
  - REST에서는 일반적으로 JSON 형식을 사용하지만, XML, Text, RSS 등의 형식도 가능하다.
  - 표현은 자원의 현재 상태를 클라이언트가 이해할 수 있도록 전달하는 수단이다.

<aside>
💡

**HTTP**는 HyperText Tranfer Protocol의 약자로 웹에서 클라이언트(주로 브라우저)와 서버가 통신하기 위해 사용하는 프로토콜이다.

| 항목               | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| 클라이언트         | 요청을 보내는 쪽 (브라우저, 모바일 앱 등)                    |
| 서버               | 요청을 받아 처리하고 응답을 보내는 쪽 (웹 서버, API 서버 등) |
| 요청 (Request)     | 클라이언트가 서버에게 정보를 요청하는 메시지                 |
| 응답(Response)     | 서버가 요청을 처리한 후 클라이언트에게 보내는 메시지         |
| 무상태 (Stateless) | 각 요청은 독립적이며 이전 요청의 상태를 서버가 기억하지 않음 |

**HTTP 동작 방식**

- 클라이언트가 요청(Request)하면 →
  - 예: `GET /index.html`
  - 요청 헤더에 메서드, URI, 헤더 정보, 바디 등이 포함될 수 있음
- 서버가 응답(Response) →
  - 예: `200 OK`, HTML 문서, JSON, 이미지 등

**HTTP 상태 코드**

다양하게 존재하지만 대표적으로 몇 개 정리하자면 아래와 같다.

| 코드                      | 의미                          |
| ------------------------- | ----------------------------- |
| 200 OK                    | 요청 성공                     |
| 201 Created               | 새 자원 생성 성공             |
| 204 No Content            | 성공했지만 반환할 콘텐츠 없음 |
| 400 Bad Request           | 잘못된 요청                   |
| 401 Unauthorized          | 인증 필요                     |
| 403 Forbidden             | 접근 권한 없음                |
| 404 Not Found             | 자원 없음                     |
| 500 Internal Server Error | 서버 오류                     |

**HTTP vs HTTPS**

| 항목    | HTTP                    | HTTPS                     |
| ------- | ----------------------- | ------------------------- |
| 보안    | 없음                    | SSL/TLS 암호화 사용       |
| 포트    | 80번                    | 443번                     |
| 사용 예 | 테스트, 비공개 네트워크 | 실서비스, 로그인, 결제 등 |

</aside>

## REST의 특징 및 장단점

### **특징**

1. Uniform Interface (유니폼 인터페이스)
   1. Uniform Interface란 URI로 지정된 리소스에 대해 일관된 방식의 인터페이스(HTTP 메서드 등) 를 사용하여 자원을 조작하는 REST의 핵심 원칙
   2. 시스템의 아키텍처를 단순하게 만들고, 클라이언트와 서버 간 상호작용을 예측 가능하게 함
2. Stateless (무상태성)
   1. REST는 무상태성의 성격을 가진다. 이는 서버가 이전 요청과의 상태를 저장하지 않고, 모든 요청은 독립적으로 처리함을 의미한다.
   2. 세션 정보나 쿠키 정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 처리해주면 된다. 덕분에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않아도 되기에 구현이 단순해진다.
   3. 때문에 클라이언트는 매 요청마다 필요한 인증 정보(예: 토큰)를 함께 전송해야 한다.
3. Cacheable (캐시 가능)
   1. HTTP, 기존 웹 표준을 그대로 사용하기 때문에 웹에서 사용하는 기존 인프라를 그대로 활용이 가능하다. HTTP가 가진 캐싱 기능도 적용이 가능하며 HTTP 프로토콜 표준에서 사용하는 Last-Modified나 E-Tag 등의 헤더를 사용하면 불필요한 데이터 전송을 줄이고 성능을 향상시킬 수 있다.
4. Self-descriptiveness (자체 표현 구조)
   1. REST API는 자체 표현(self-descriptive) 구조를 갖고 있어, 메시지 자체에 요청 및 응답에 필요한 정보가 포함되어 있다.
   2. 예를 들어 JSON 형태의 응답 데이터에 필드명, 상태 코드 등이 포함되어 있어 별도의 문서 없이도 이해가 가능하다.
5. Client - Server 구조
   1. REST는 클라이언트-서버 구조를 따르기에 클라이언트는 사용자 인터페이스와 요청을 담당하고, 서버는 자원과 로직을 처리한다.
   2. 클라이언트와 서버의 개발 책임이 명확히 분리되어 독립적인 개발 및 배포가 가능하다.
6. 계층형 구조
   1. REST 아키텍처는 계층형 구조를 허용하여 보안, 로드 밸런싱, 암호화 등의 중간 계층을 삽입할 수 있다.
   2. 예를 들어, 프록시 서버나 게이트웨이 등을 활용해 네트워크 구조의 유연성과 확장성을 확보할 수 있다.

### **장점**

- HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구축할 필요가 없다.
- HTTP 표준 프로토콜을 따르는 모든 플랫폼에서 사용 가능하다.
- REST는 HTTP 및 URI 기반의 아키텍처 스타일을 따르기 때문에 다양한 플랫폼에서 높은 범용성과 확장성을 가진다.
- REST API 메시지가 의도하는 바를 쉽게 파악 가능하다.
- 클라이언트-서버 구조와 일관된 URI 및 HTTP 메서드 사용 덕분에 인터페이스가 명확해지고, 팀 간 충돌이나 의사소통 오류를 줄일 수 있다.
- 서버와 클라이언트의 역할을 명확히 분리한다.

### **단점**

- REST는 명확한 공식 표준이 없는 아키텍처 스타일이기 때문에, API 설계 방식이 개발자 또는 팀에 따라 달라질 수 있으며, 일관성을 유지하기 위해 내부 규칙(컨벤션)이 필요하다.
- REST는 주로 GET, POST, PUT, DELETE 등의 HTTP 메서드에 의존하는데, 복잡한 동작이나 트랜잭션 처리에는 표현의 제약이 있을 수 있다.
- 브라우저를 통해 테스트할 일이 많은 서비스라면 쉽게 고칠 수 있는 URL보다 Header 값이 더 어렵게 느껴진다. 특히 `Authorization`, `Content-Type`, `Accept` 등의 헤더는 단순 URL 호출만으로는 설정이 어려워, Postman 같은 툴이 필요하다.
- 일부 구형 브라우저나 프록시 서버에서는 PUT, DELETE 메서드에 대한 지원이 제한적일 수 있고, CORS 정책으로 인해 제약이 발생할 수 있습니다.

## Rest API

REST 기반으로 서비스 API를 구현한 것을 의미한다.

API는 항상 메뉴얼도 함께 제공되어야 한다. URI를 모르면 클라이언트가 사용할 수 없기 때문이다.

### REST API 설계 규칙

1. 슬래시 구분자 (/)는 계층 관계를 나타내는 데 사용한다.

   `http://restapi.example.com/houses/apartments`

2. URI 마지막 문자로 슬래시를 포함하지 않는다.

   1. REST API는 분명한 URI를 만들어 통신해야 하기에 혼동이 없도록 URI 경로의 마지막에는 슬래시를 사용하지 않는다.
   2. 서버 구현에 따라 리디렉션이 자동 처리되는 경우도 있으므로 일관된 규칙을 유지하는 것이 더 중요하다.

   `http://example.com/posts/  (X)`

3. 하이픈 (-)은 URI 가독성을 높이는 데 사용한다.
   1. 불가피하게 긴 URI 경로를 사용하게 된다면 하이픈을 사용해 가독성을 높인다.
   2. `/user-accounts`, `/monthly-reports` 처럼 단어 구분용으로 좋다.
4. 언더바 (\_)는 URI에 사용하지 않는다.
   1. 언더바는 보기 어렵거나 밑줄 때문에 문자가 가려지기도 하여 가독성을 위해 사용하지 않는다.
5. URI 경로에는 대문자 사용을 피하고 소문자 사용을 지향한다.
   1. URI 문법 형식에서 URI 스키마와 호스트를 제외하고 대소문자를 구별하도록 규정한다.
   2. 따라서 혼동 방지를 위해 소문자만 쓰는 것이 좋다.
6. REST API에서는 메시지 bocy 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함하지 않는다. 대신 Accept 헤더를 사용한다.
   1. REST는 콘텐츠 협상을 MIME 타입 (`Accept`)을 통해 처리하는 것이 표준이다.
7. 리소스 간에 연관 관계가 있는 경우 `/리소스명/리소스 ID/관계가 있는 다른 리소스명`으로 작성한다. → `GET : /users/{userid}/devices (일반적으로 소유 ‘has’의 관계를 표현할 때)`
8. HTTP 메서드에 맞는 명확한 의미를 갖는 URI 사용한다.
9. 컬렉션 (복수명) 명사를 사용한다.
   1. 리소스는 **항상 복수형 명사**로 표현하는 것이 일반적이다.
   2. `GET /user ❌` → `GET /users ✅`
10. 필터링, 정렬, 페이지네이션은 쿼리 파라미터로 처리한다.
    1. URI는 리소스를 식별하고, 조회 조건은 쿼리스트링으로 분리하는 것이 표준적이다.
    2. `GET /users?age=20&sort=name&page=2&limit=10`
11. 에러 응답은 HTTP 상태 코드 + 의미 있는 메시지로 제공하는 것이 좋다.

    ```json
    HTTP/1.1 404 Not Found
    {
      "error": "User not found",
      "code": 404
    }
    ```

12. 버전 관리는 URI에 포함시키는 것이 일반적이다.

    1. 혹은 `Accept` 헤더에 버전을 포함할 수도 있지만, URI 방식이 더 널리 사용된다.

    ```bash
    GET /v1/users
    GET /api/v2/users
    ```

13. 기본적으로 리소스명은 명사로 작성하지만 리소스가 아닌 행위 자체가 리소스일 때에는 명사처럼 표현된 행위 리소스를 사용할 수 있다.

    1. 아래의 경우 리소스에 대한 하위 행위로 받아들여져 REST 위반으로 보지는 않는다. 단 이 경우에도 URI 자체는 명사 구조처럼 보이도록 설계하고 HTTP 메서드로 행위를 표현한다.

    | HTTP   | URI                         | 의미                    |
    | ------ | --------------------------- | ----------------------- |
    | `POST` | `/users/123/active`         | 특정 사용자 활성화 요청 |
    | `POST` | `/orders/123/cancel`        | 특정 주문 취소 요청     |
    | `POST` | `/users/123/reset-password` | 비밀번호 초기화 요청    |

### RESTful

**REST의 원리를 따르는 시스템을 RESTful이라고 지칭한다.**

→ REST API를 제공하는 웹 서비스를 RESTful하다고 말할 수 있다.

**RESTful의 목적은 이해하기 쉬운 REST API를 만드는 데에 있다.**

RESTful한 API를 구현하는 근본적인 목적이 성능 향상에 있다기보다는 일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는 것, 가독성, 일관성, 유지 보수성에 초점을 두는 설계 방식이며 실시간 처리나 고성능 트래픽 처리에서는 오히려 gRPC, GraphQL, WebSocket 등 다른 방식이 더 적합할 수 있다.

**RESTful하지 못한 경우**

REST API의 설계 규칙을 올바르게 지키지 못한 시스템은 REST API를 사용하더라도 RESTful하지 못한 시스템이라고 한다.

| RESTful하지 못한 설계      | 이유                                                |
| -------------------------- | --------------------------------------------------- |
| `POST /getUserInfo`        | HTTP 메서드 `GET`을 써야 하는 상황인데 `POST` 사용  |
| `GET /deleteUser/1`        | 삭제는 `DELETE /users/1` 형태로 해야 RESTful        |
| `PUT /students/updateName` | 메서드에 해당 행위를 URI에 넣은 것은 REST 원칙 위반 |

| 목적             | RESTful한 방식                                      |
| ---------------- | --------------------------------------------------- |
| 사용자 정보 조회 | `GET /users/123`                                    |
| 사용자 생성      | `POST /users`                                       |
| 사용자 삭제      | `DELETE /users/123`                                 |
| 사용자 이름 변경 | `PATCH /users/123` with body `{ name: "new name" }` |
